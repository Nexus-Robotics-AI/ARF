# 🔥 ARF 模块开发参考文档：应用层 (Application)

> 🎯 **角色定位:** ARF的"产品"与"门面" - 将技术能力封装为面向场景的解决方案。
>
> 📦 **模块代号:** `arf-edge-app`
>
> ⚡ **所属:** ARF 边缘平台 (Edge Plane)

## 📋 1. 核心职责与设计理念

### 🎯 核心使命 (Core Mission)

作为ARF技术价值的“最终封装”和“用户门面”，应用层的核心使命是**将底层的算法能力(`ACR`)和决策逻辑(`DIL`)，打包成面向最终用户的、可组合的、个性化的、开箱即用的解决方案**。它的进化目标是超越固化的应用套件，成为一个支持**动态技能扩展**、能够**学习用户偏好**并提供**主动式上下文服务**的智能交互终端。

主要应用场景包括：

- **🏭 工业应用:** 视觉引导的抓取与放置、缺陷检测、自主移动物流。
- **🏡 家庭服务:** 老人陪护、智能家居控制、家庭清洁、智能陪聊。
- **🔬 科研应用:** 快速验证新的VLA、强化学习、人机交互算法的实验平台。提供支持**力反馈遥操作**的实验平台。
- **🏥 医疗应用:** 辅助手术、康复训练、智能诊断。提供支持**力反馈遥操作**的实验平台，用于远程进行精细装配、辅助手术等需要物理交互的任务。

- **🏪 技能商店:** 用户可以像使用智能手机一样，浏览并“安装”新的机器人技能（如“学会泡咖啡”、“宠物互动游戏”），不断扩展机器人的能力。
- **❤️ 个性化助手:** 通过学习用户的习惯和偏好，提供真正个性化的服务，从“通用工具”变为“专属伙伴”。

### 🏗️ 核心架构：技能商店 + 个性化引擎 (Skill Store + Personalization Engine)

应用层的设计将“后端业务逻辑”与“前端用户界面”分离。

- **应用套件 (Application Suite):** 这是一个**后端的、无界面的服务**。它的核心是一个**高度定制化的`DIL`服务**，内部编排了一组为特定场景精选的`ACR`算法容器。例如，“工业抓取套件”会加载高精度的检测算法，而“家庭陪聊套件”则会加载语音识别和生成算法。
- **用户界面 (User Interface):** 这是一个**独立的前端应用**（Web/移动端）。它通过`API`层提供的gRPC或RESTful接口与后端的“应用套件”进行通信，负责向用户展示信息和接收用户指令。
- **个性化与上下文引擎 (Personalization & Context Engine):** 这是V1.1架构的核心扩展。它是一个新的后端组件，负责管理用户模型，学习用户偏好，并融合上下文信息，为`技能执行引擎`提供个性化决策的依据。

### ⚖️ 设计原则 (Design Principles)

- **🎯 场景驱动 (Scenario-Driven):** 应用层的一切设计都必须围绕最终用户的具体场景和需求展开。
- **📦 开箱即用 (Out-of-the-Box):** 应用套件应提供预配置好的默认参数和行为，让用户可以最小化配置就立即开始使用。
- **🧩 可组合与可扩展 (Composable & Extensible):** 机器人的能力应由一系列可独立安装、更新和组合的“技能”构成。
- **🔧 高度可配置 (Highly Configurable):** 为专业用户提供丰富的配置选项，允许他们根据自己的具体需求，调整应用的行为。
- **🎨 用户友好:** 前端UI的设计必须极其简洁、直观、易于上手，即使是非技术用户也能轻松操作。
- **💡 主动智能 (Proactive Intelligence):** 应用应力求理解用户意图和上下文，提供预测性和主动性的服务。

------



## 📝 2. 核心需求 (Core Requirements)



| **ID** | **需求描述**                             | **验收标准**                                                 | **优先级**       |
| ------ | ---------------------------------------- | ------------------------------------------------------------ | ---------------- |
| **P1** | **场景化解决方案 (Scenario Solution)**   | 必须提供至少一个完整的、端到端的应用套件（如“家庭服务应用”），能够完成一个有意义的任务。 | **最高**         |
| **P2** | **用户交互界面 (User Interface)**        | 必须提供一个Web或移动端UI，让用户可以与应用套件进行交互（如下达指令、查看状态）。 | **最高**         |
| **P3** | **任务管理 (Task Management)**           | 应用层必须能管理任务的完整生命周期，包括任务的提交、监控、取消和结果查询。 | **高**           |
| **P4** | **应用配置与持久化 (App Configuration)** | 必须提供一种机制，允许用户自定义应用的参数（如机器人名字、工作区域），并将这些配置持久化存储。 | **高**           |
| **P5** | **多应用支持 (Multi-App Support)**       | (未来规划) ARF平台应支持同时安装和运行多个不同的应用套件，并允许用户在它们之间切换。 | **中**           |
| **P6** | **技能商店与动态安装**                   | **[V1.1+ 新增]** 必须提供一个“技能商店”的用户界面和后端机制，支持用户浏览、安装和卸载新的机器人技能。 | **最高 (V1.1+)** |
| **P7** | **用户建模与个性化**                     | **[V1.1+ 新增]** 系统必须能为每个用户建立档案，记录其偏好和习惯，并在执行任务时应用这些偏好。 | **高 (V1.1+)**   |
| **P8** | **主动式服务**                           | **[V1.1+ 新增]** 应用必须能基于上下文信息（时间、地点、用户状态），在没有明确指令的情况下，主动向用户发起服务建议。 | **中 (V1.1+)**   |

## ⚙️ 3. 关键功能与子模块架构

### 🧠 3.1 应用套件 (Application Suite)

**后端大脑**：每一个应用套件，本质上都是一个**“特化”的`DIL`服务**。

- **场景化决策流:** 应用套件内部会包含一个为特定场景（如家庭环境）高度优化的行为树或状态机。
- **精选算法集:** 套件的配置文件会明确指定它依赖哪些`ACR`算法容器。在启动时，它会请求`ACR运行时`加载这些特定的算法。
- **业务逻辑封装:** 封装了该场景下的所有业务逻辑，例如，在家庭服务应用中，“取水”任务如何被分解和执行。
- **技能加载器:** 负责从`插件市场` 下载已安装的“技能包”（可能是一个行为树配置、一个`ACR`容器列表或一个Python脚本），并将其注册到`DIL`的策略库中。
- **任务分解与技能编排:** 当收到一个复杂的用户指令时（如“帮我准备一下开会要用的东西”），它会调用`DIL`的任务规划能力，将指令分解为对多个已安装技能的调用序列（如`find_laptop` -> `find_notebook` -> `bring_to_me`）。

### 💻 3.2 用户界面 (User Interface - UI)

**交互窗口**：一个独立的前端项目。

- **状态可视化:** 通过订阅`DMS`或轮询`API`层，实时显示机器人的位置、状态、摄像头画面等。
- **任务控制:** 提供按钮、输入框等UI元素，让用户可以下达指令（如“去厨房”、“找到我的手机”）。
- **配置管理:** 提供一个设置页面，允许用户修改应用的参数。
- **技能商店UI:** 一个类似App Store的界面，用户可以在此浏览、搜索、查看技能详情并一键安装或卸载。
- **个性化设置:** 提供一个设置页面，允许用户查看和修改AI学习到的自己的偏好。



### 📡 3.3 API层 (API Layer)

**前后端桥梁**：这是位于`应用套件`和`UI`之间的一个**可选但推荐**的中间层。

- **协议转换:** 将内部的gRPC接口转换为对Web前端更友好的RESTful API或WebSocket。
- **认证与授权:** 负责用户认证和权限管理。
- **请求聚合:** 可以将前端的多次请求聚合为对后端的一次调用，减少通信开销。



### 💡 3.4 个性化与上下文引擎 (Personalization & Context Engine)



**专属管家角色**：这是位于`UI`和`技能执行引擎`之间的一个新的核心服务。

- **用户模型管理器:** 负责创建和管理每个用户的持久化档案，存储在本地或云端`数据中心`。
- **上下文融合器:** 订阅`DMS` 上的各种状态信息（机器人在哪个房间、现在几点、用户的日历），形成一个丰富的实时上下文。
- **主动服务决策器:** 基于当前的上下文和用户模型，通过预设规则或一个小型决策模型，判断是否应该以及如何向用户发起一个主动服务。

## 🔗 4. 接口设计与数据流

应用层是ARF信息流的顶端。

### 📥 输入数据流

| **数据源**      | **数据类型**                   | **优先级** | **延迟要求** | **示例场景**                  |
| --------------- | ------------------------------ | ---------- | ------------ | ----------------------------- |
| **最终用户**    | `TaskRequest` (HTTP/WebSocket) | `NORMAL`   | `< 1s`       | 用户在手机App上点击“开始清扫” |
| **DIL决策层**   | `TaskStatus` (gRPC)            | `NORMAL`   | `< 1s`       | 应用套件向UI报告任务进度      |
| **DMS数据总线** | `BusMessage` (各类状态)        | `LOW`      | `< 2s`       | UI订阅机器人电量信息          |

### 📤 输出数据流

| **目标模块**  | **数据类型**               | **保证** | **性能指标**           |
| ------------- | -------------------------- | -------- | ---------------------- |
| **DIL决策层** | `SubmitTaskRequest` (gRPC) | 可靠调用 | 任务提交成功率 > 99.9% |
| **最终用户**  | UI界面更新 (JSON/HTML)     | 实时响应 | 界面刷新延迟 < 500ms   |

### 🧬 核心API草案 (`api_gateway.proto`)

```
// protos/arf/edge/v1/api_gateway.proto
// 这个API服务由API层提供，作为UI和应用套件之间的网关
syntax = "proto3";

package arf.edge.v1;

import "arf/edge/v1/dil.proto";
import "arf/v1/common.proto";

// API网关服务
service ApiGatewayService {
  // 提交一个新任务（可以是抽象的目标）
  rpc StartTask(dil.SubmitTaskRequest) returns (dil.SubmitTaskResponse);
  // 获取任务状态
  rpc GetTaskStatus(dil.GetTaskStatusRequest) returns (dil.TaskStatus);
  // 订阅机器人实时状态的流
  rpc StreamRobotState(StreamRobotStateRequest) returns (stream RobotState);

  // --- V1.1 新增 ---
  // 列出技能商店中所有可用的技能
  rpc ListAvailableSkills(ListAvailableSkillsRequest) returns (ListAvailableSkillsResponse);
  // 安装/卸载一个技能
  rpc ManageSkill(ManageSkillRequest) returns (ManageSkillResponse);
  // 获取/更新用户偏好设置
  rpc UpdateUserPreferences(UpdateUserPreferencesRequest) returns (UserPreferences);
}

// 技能信息
message Skill {
    arf.v1.PluginIdentifier id = 1;
    string display_name = 2;
    string description = 3;
    bool is_installed = 4;
}

message ListAvailableSkillsResponse {
    repeated Skill skills = 1;
}

message StreamRobotStateRequest {}

message RobotState {
    double battery_level = 1;
    // ... 其他需要UI展示的状态
}
```

## 🛠️ 5. 技术栈与开发环境

### 💻 核心技术栈

| **技术领域**     | **选型**                       | **版本要求** | **用途说明**              |
| ---------------- | ------------------------------ | ------------ | ------------------------- |
| **应用套件语言** | **Python**                     | `3.10+`      | 与DIL和ACR无缝集成        |
| **API层语言**    | **Go / Python**                | `Go 1.21+`   | 构建高性能的Web后端       |
| **Web后端框架**  | **FastAPI (Python), Gin (Go)** | 最新稳定版   | 提供RESTful/WebSocket接口 |
| **Web前端框架**  | **React / Vue.js**             | 最新稳定版   | 构建现代化的单页应用(SPA) |
| **移动端框架**   | **Flutter / React Native**     | 最新稳定版   | (可选)构建跨平台的移动App |

## 🔧 6. 开发实施细节

### 🏗️ 6.1 项目结构 V1

```
application/
└── home-assistant-app/            # 一个完整的应用套件项目
    ├── backend/                   # 后端应用套件 (特化的DIL)
    │   ├── main.py
    │   ├── logic/
    │   └── Dockerfile
    ├── frontend/                  # 前端UI项目 (React)
    │   ├── src/
    │   ├── public/
    │   └── Dockerfile
    └── deployments/
        └── docker-compose.yml     # 一键启动该应用的前后端
```

### 🧪 6.2 测试与验证策略



- **后端单元测试:** 对应用套件中的业务逻辑进行单元测试。
- **端到端测试 (E2E):** 使用Cypress或Playwright等工具，编写自动化测试脚本，模拟用户在前端UI上的完整操作（如登录->下达指令->查看结果），验证整个应用流程的正确性。
- **[V1.1 更新] 标准化主观质量评测 (Standardized Subjective Quality Evaluation):** 应用的核心主观性能（如交互自然度、任务完成质量、用户满意度）**必须**通过`评测模块`提供的**‘人在环路(HIL-E)’评测流水线**进行量化。开发团队应为每个核心技能定义主观评测问卷，并定期执行HIL-E流程，以数据驱动的方式迭代和优化用户体验。
- **[V1.1 新增] 复杂逻辑调试 (Complex Logic Debugging):** 对于由多个技能动态组合而成的复杂任务，开发者应使用`Dev`模块提供的**可视化调试套件**进行调试。特别是**行为树可视化器 (`arf-cli dev debug bt`)**，它是理解和排查`技能执行引擎`内部实时决策逻辑的首选工具。

------



## 🚀 7. 开发任务 (Getting Started)





#### **第一阶段：核心业务逻辑与无头(Headless)交互**



- **任务1：开发第一个应用套件后端**
  - **交付物:** 一个`home-assistant-backend`服务。它是一个特化的`DIL`，能够接收gRPC请求，并完成一个核心任务（例如，导航到指定房间）。
- **任务2：开发`arf-cli`的应用层交互命令**
  - **交付物:** 实现`arf app start-task "go to kitchen"`和`arf app get-status <task_id>`等CLI命令，作为第一个“无头”UI，用于测试和验证后端应用套件。



#### **第二阶段：Web前端与API网关**



- **任务1：开发API网关**
  - **交付物:** 一个API Gateway服务，将后端的gRPC接口转换为RESTful API。
- **任务2：开发Web前端UI v0.1**
  - **交付物:** 一个简单的React或Vue前端应用，至少包含一个输入框用于发送指令，一个区域用于显示机器人状态和任务反馈。
- **任务3：前后端联调**
  - **交付物:** 用户可以在Web界面输入“go to kitchen”，并能看到任务状态从“RUNNING”变为“SUCCEEDED”。



#### **第三阶段：丰富功能与用户体验优化**



- **任务1：实现实时状态更新**
  - **交付物:** UI通过WebSocket从API网关订阅机器人状态，实现电量、位置等信息的实时刷新。
- **任务2：开发应用配置界面**
  - **交付物:** 用户可以在UI上配置机器人的名字、家庭地图等信息，并能持久化保存。
- **任务3：用户体验测试与迭代**
  - **交付物:** 根据第一批用户的反馈，优化UI布局和交互流程。



#### **第四阶段：移动端与多应用支持**



- **任务1：开发移动App v0.1**
  - **交付物:** (可选)一个Flutter或React Native App，提供与Web端对等的核心功能。
- **任务2：实现“技能商店”原型**
  - **交付物:** UI中出现一个“技能商店”页面，可以从`插件市场`拉取并展示可安装的应用套 more
- **任务3：实现多应用切换**
  - **交付物:** 用户可以在不同的已安装应用套件之间进行切换。



#### **第五阶段及以后：迈向个性化技能商店 (Towards Personalized Skill Store)**



*此部分为V1.1及后续版本规划，旨在打造可进化的用户体验。*

- **任务5.1: 实现技能商店后端**
  - **交付物:** 完整实现`ListAvailableSkills`和`ManageSkill` API。`技能执行引擎`能够根据API调用，从`插件市场`拉取并动态加载/卸载技能包。
- **任务5.2: 开发技能商店前端UI**
  - **交付物:** 在Web或移动App中，用户可以实际看到一个技能列表，并能通过点击按钮完成技能的安装和卸载。
- **任务5.3: 实现个性化引擎原型**
  - **交付物:** 实现`个性化与上下文引擎`，至少能记录和应用一项用户偏好（例如，用户喜欢的音乐类型）。在一个测试任务中，机器人的行为会根据不同的用户偏好而改变。
- **任务5.4: 开发第一个主动式服务**
  - **交付物:** 实现一个简单的主动式服务。例如，当机器人在早上8点到9点之间，且在厨房检测到用户时，会主动问候并询问“早上好，需要为您冲一杯咖啡吗？”。
