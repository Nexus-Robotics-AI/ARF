# ARF 跨平台与硬件适配策略 V1.1





## 1. 核心设计哲学



我们的核心哲学是**“封装复杂性，提供统一性”**。我们不期望每个开发者都成为交叉编译和驱动调试的专家。相反，我们将适配工作视为平台的核心责任，通过以下三大策略，为最终用户和上层开发者提供一个“一次开发，随处运行”的理想环境。

1. **策略一：容器化是我们的“通用操作系统” (Containerization as Universal OS)**
2. **策略二：插件市场是我们的“能力清单与兼容性矩阵” (Marketplace as Capability & Compatibility Matrix)**
3. **策略三：CI/CD是我们的“自动化适配工厂” (CI/CD as Adaptation Factory)**



## 2. 核心挑战与适配方案



我们将适配挑战分解为四个主要维度：**操作系统 (OS)**, **CPU架构**, **GPU与驱动**, 以及 **实时内核**，并阐述ARF如何通过上述策略应对每一个挑战。



### **A. 操作系统 (OS) 适配**



- **挑战:** 如何让ARF在Windows, Linux, macOS等不同操作系统上都能可靠运行？
- **解决方案:** **通过Docker容器抹平差异，并通过`HAL`层封装OS特定API。**
  - **对于上层应用 (`DIL`, `APP`等):** 体验是完全透明的。它们运行在标准的Ubuntu容器环境中，无需关心宿主机是Windows还是Linux。
  - **对于底层驱动 (`HAL`):** `HAL`驱动容器是唯一需要感知操作系统的模块。我们会为同一个设备提供**针对不同操作系统的驱动版本**，并在`插件市场`中进行明确标识：
    - `webcam-driver:1.0-linux-amd64` (内部使用`V4L2`)
    - `webcam-driver:1.0-windows-amd64` (内部使用`DirectShow`)
  - **关键在于：** 无论内部实现如何，它们对外暴露的都是**同一个**`hal.proto` gRPC接口。上层模块的调用方式完全一致，OS差异被`HAL`层彻底屏蔽。



### **B. CPU 架构 (CPU Architecture) 适配**



- **挑战:** 如何让ARF同时运行在`x86_64`（桌面/服务器）和`AArch64`（NVIDIA Jetson/树莓派等嵌入式设备）上？
- **解决方案:** **在CI/CD流程中，通过`docker buildx`实现自动化的多架构镜像构建。**
  - **实现方式:** 我们的`CI/CD`流水线 会为**每一个**ARF模块（服务、驱动、算法）自动构建出支持`linux/amd64`和`linux/arm64`等多种平台的镜像清单（Image Manifest）。
  - **对用户而言:** 体验是**完全透明**的。当用户在一台NVIDIA Jetson (`arm64`)上执行`docker pull arf/dms-service:v1.2`时，Docker会自动拉取`arm64`版本的镜像层。当他在一台x86服务器上执行同样命令时，则会自动拉取`amd64`版本的镜像层。
  - **V1.1扩展适用性:** 该策略同样适用于V1.1中引入的新硬件驱动，如**力/扭矩传感器** 和**力反馈遥操作设备**，确保它们也能在不同CPU架构的边缘设备上运行。



### **C. GPU 版本与驱动适配**



- **挑战:** 这是最复杂的部分。AI算法对NVIDIA驱动、CUDA、cuDNN、TensorRT的版本高度耦合和敏感。
- **解决方案:** **将所有GPU依赖打包进`ACR`容器，并通过`插件市场`的“标签化”进行精确的版本匹配。**
  1. **精确的基础镜像：** 每个需要GPU的`ACR`算法容器，其`Dockerfile`都必须从一个**精确版本的NVIDIA官方基础镜像**开始（如 `nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu22.04`）。
  2. **版本化的标签：** 在`插件市场`中，我们发布的不是一个通用的插件，而是带有详细环境依赖标签的插件：
     - `object-detector-yolov8:1.0.0__cuda-11.8__torch-2.0`
     - `object-detector-yolov8:1.1.0__cuda-12.1__torch-2.1`
  3. **运行时兼容性检查：** 边缘端的`ACR运行时` 在启动时会检测宿主机的NVIDIA驱动版本。当`DIL`请求运行某个算法时，`ACR运行时`会查询`插件市场`的元数据，自动选择并拉取与当前宿主机驱动**兼容的最佳版本**进行运行。如果不兼容，则会拒绝运行并向上层报告错误。



### **D. 实时内核 (Real-time Kernel) 适配**



- **挑战:** `RTS`模块的硬实时能力高度依赖底层操作系统的内核特性，特别是Linux的`PREEMPT_RT`补丁。
- **解决方案:** **在`RTS`库中进行抽象和条件编译，并在`插件市场`中明确能力等级。**
  1. **抽象与降级:** `RTS`模块本身提供一个**平台无关的C++ API**。在其内部实现中，我们使用**条件编译**（`#ifdef __linux__` ... `#elif _WIN32`）来包含特定于操作系统的代码。
  2. **明确的能力声明:** ARF的**硬实时能力** (微秒级抖动) **仅在已应用`PREEMPT_RT`补丁的特定Linux系统上受支持和保证**。
  3. **优雅降级 (Graceful Degradation):** 在其他操作系统（如标准Linux、Windows）上，`RTS`模块依然可以编译和运行，但只能提供“尽力而为”的**软实时**保证。
  4. **市场标签:** 需要`RTS`硬实时能力的`HAL`驱动（如高频电机控制器），将在`插件市场`中被标记为需要`capability:rts_hard_realtime`，`舰队管理`模块在部署时会检查目标设备是否满足此能力要求。



## 3. 受影响模块与适配方案总结



| **适配维度**      | **核心策略**                | **主要受影响模块**                 | **适配方案说明**                                             |
| ----------------- | --------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| **操作系统 (OS)** | **容器化 + HAL封装**        | `HAL`, `Application`, `DIL`, `ACR` | 除`HAL`驱动需针对各OS单独实现外，其他模块均运行在统一的Linux容器环境中，实现OS无关。 |
| **CPU架构**       | **CI/CD多架构构建**         | `所有模块`                         | `CI/CD`流水线使用`docker buildx`为所有容器镜像自动构建多架构版本，对用户透明。 |
| **GPU与驱动**     | **依赖内封装 + 市场标签化** | `ACR`, `Simulation`, `Converter`   | 将CUDA等依赖打包进容器内。`插件市场`通过详细标签管理兼容性，`ACR运行时`负责在边缘端进行动态匹配。 |
| **实时内核**      | **库内抽象 + 能力声明**     | `RTS`, `HAL`, `遥操作`             | `RTS`库通过条件编译适配不同内核。硬实时能力作为一种特殊的“设备能力”在`插件市场`和`舰队管理`中进行管理。 |

