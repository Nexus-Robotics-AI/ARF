# ARF Rust 语言设计与代码规范

**适用模块:** `HAL` 等高安全、高性能模块

## 1. 设计思想 (Guiding Principles)

- **安全至上:** 充分利用Rust的所有权、生命周期和借用检查器，从编译器层面杜绝内存安全和数据竞争问题。**严禁**滥用`unsafe`代码块，任何`unsafe`的使用都必须有详尽的注释说明其必要性和安全性保证。
- **面向表达式:** 善用Rust的表达式特性（如`if/let`, `match`）编写简洁、富有表现力的代码。
- **零成本抽象:** 善用`trait`和泛型来构建可复用、高性能的抽象。接口设计应清晰地分离行为和数据。
- **错误处理:** 拥抱`Result`和`Option`，进行明确、健壮的错误处理。**严禁**使用`.unwrap()`或`.expect()`，除非在测试或不可恢复的`panic`场景中（例如，一个关键配置的缺失）。推荐使用`thiserror`和`anyhow`库来构建丰富的错误类型。

## 2. 代码要求 (Coding Standards)

### 2.1 格式化与检查

- **强制:** 所有代码提交前，**必须**使用`rustfmt`进行格式化。
- **强制:** 所有代码**必须**通过`clippy::all`和`clippy::pedantic`的所有检查，任何允许(allow)的lint都必须在代码中有注释说明理由。

### 2.2 命名规范

- 遵循 **Rust API Guidelines**。
- **变量/函数:** `snake_case`。
- **类型/Trait/枚举:** `CamelCase`。
- **宏:** `snake_case!`。
- **常量:** `UPPER_SNAKE_CASE`。

### 2.3 模块化

- 使用`mod`和`use`清晰地组织代码结构。每个crate都应该有一个明确的、最小化的公共API。
- 遵循“一个模块一个文件”的原则，保持代码文件的职责单一。

### 2.4 注释

- 所有公有项（`pub`）**必须**有文档注释（`///`），并包含示例代码（doctests）。
- 复杂的内部逻辑应使用行注释（`//`）或块注释（`/* ... */`）解释“为什么”，而不是“做什么”。

### 2.5 依赖管理

- 使用`Cargo.toml`管理依赖，并锁定具体版本。
- 尽可能选择`#![no_std]`兼容的库，