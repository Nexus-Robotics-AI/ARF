# ARF 生态系统架构总览

**文档目的:** 本文档是ARF项目的最高级别架构纲领，旨在为所有团队成员提供一个关于系统全部模块的、统一的、全面的信息索引。

## 第一部分：生态系统全景

ARF是一个覆盖机器人智能**全生命周期**的、**云-边协同**的生态系统，由两大核心平面构成。

- **ARF云端平面 (Cloud Plane):** 智能的“**摇篮**”和“**健身房**”。负责数据处理、模型训练、仿真评测和大规模管理任务。
- **ARF边缘平面 (Edge Plane):** 智能的“**身体**”和“**执行者**”。负责在机器人本体上实时运行感知、决策和控制任务。

## 第二部分：模块详细信息总览

### **ARF 云端平面 (ARF Cloud Plane)**

| **模块名称**                 | **核心职责**                                                 | **关键功能 / 子模块**                                        | **输入**                                            | **输出**                                                | **主选技术栈**                       |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------------------- | ------------------------------------ |
| **仿真模块 (Simulation)**    | 提供大规模、高并发、物理精准的虚拟测试环境。                 | 1. 场景管理器<br>2. 机器人模型库<br>3. 传感器模拟器<br>4. 结果记录器 | 1. 场景ID<br>2. 机器人模型ID<br>3. 待评测算法/模型  | 1. 仿真传感器数据<br>2. 任务执行日志<br>3. 性能评测分数 | NVIDIA Isaac Sim, Gazebo, Kubernetes |
| **数据中心** (Data **Hub)**  | 作为生态系统的“中央数据湖”，统一收集、存储和管理所有数据。   | 1. 数据采集接口<br>2. 数据存储层<br>3. 数据管理与版本控制<br>4. 数据查询API | 1. 真实机器人数据<br>2. 仿真数据<br>3. 第三方数据集 | 1. 结构化的、可供训练/分析的数据集                      | AWS S3/MinIO, Apache Parquet/Arrow   |
| **数据转换模块 (Converter)** | 将不同来源、不同格式的原始数据，转换为标准化的训练数据。     | 1. 数据格式解析器<br>2. 数据清洗与增强<br>3. 数据标注工具接口<br>4. 标准化格式写入器 | 1. 原始数据流 (如ROS Bag, CSV等)<br>2. 转换规则配置 | 1. 标准化的训练数据集 (如TFRecord, Parquet)             | Python, Go, Kubernetes               |
| **训练模块 (Training)**      | 提供可伸缩的、分布式的模型训练能力。                         | 1. 训练任务调度器<br>2. 分布式训练引擎<br>3. 实验跟踪与版本控制(MLflow) | 1. 训练代码<br>2. 数据集查询语句<br>3. 超参数配置   | 1. 训练好的模型文件<br>2. 训练日志与性能指标            | Kubeflow/Ray, PyTorch, Horovod       |
| **评测模块 (Evaluation)**    | 提供标准化的、可复现的算法与模型评测流水线。                 | 1. 评测流水线编排器<br>2. 标准测试场景库<br>3. 性能指标计算器<br>4. 评测报告生成器 | 1. 待评测模型<br>2. 评测场景列表                    | 1. 详细的评测报告<br>2. 与历史版本的对比分析            | Argo Workflows/Tekton, Kubernetes    |
| **插件市场 (Marketplace)**   | 作为生态系统所有“数字资产”的中央仓库和分发中心。             | 1. 资产（驱动/算法/模型/应用）版本管理<br>2. 搜索与发现<br>3. 访问控制与权限管理 | 1. 经过评测的驱动/算法/模型/应用包                  | 1. 可供舰队管理部署的标准化软件包                       | Harbor, Nexus, Go                    |
| **舰队管理 (Fleet Mgt.)**    | 对全球范围内的机器人（边缘节点）进行大规模部署、监控和运维。 | 1. 安全OTA更新<br>2. 远程监控与诊断<br>3. 配置管理<br>4. 日志收集 | 1. 来自插件市场的软件包<br>2. 部署目标（机器人组）  | 1. 部署状态报告<br>2. 机器人健康状况数据                | Kubernetes (K3s/KubeEdge), Go        |

### **ARF 边缘平面 (ARF Edge Plane)**

| **模块名称**                              | **核心职责**                                                 | **关键功能 / 子模块**                                        | **输入**                                                     | **输出**                                                     | **主选技术栈**                             |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| **应用层 (Application)**                  | 将底层技术能力打包成面向特定垂直领域的、开箱即用的解决方案。 | 1. **工业应用套件:** 高可靠抓取、检测<br>2. **家庭服务应用:** 自然语言交互<br>3. **前沿科研应用:** 灵活的实验平台 | 1. 用户指令<br>2. DIL的状态信息                              | 1. 面向用户的UI/UX<br>2. 业务流程执行结果                    | Python, Web框架(FastAPI)                   |
| **<ins>遥操作模块 (Teleoperation)</ins>** | <ins>提供人机远程实时控制接口，允许操作员直接操控机器人，常用于数据采集引导、特殊任务处理和故障恢复。</ins> | <ins>1. 遥操作终端接口 (WebRTC, Joystick)<br>2. 低延迟指令通道<br>3. 实时视频/状态回传</ins> | <ins>1. 操作员指令 (摇杆、键盘、VR)<br>2. 机器人实时状态</ins> | <ins>1. 对HAL/RTS的直接控制指令<br>2. 向操作员终端的视频/数据流</ins> | <ins>WebRTC, C++, Python</ins>             |
| **DIL (决策智能层)**                      | 编排和调用ACR的算法能力，形成完整的任务逻辑，是机器人的“大脑”。 | 1. 行为树/状态机<br>2. 任务规划器<br>3. 强化学习/模仿学习策略<br>4. 安全监控与决策 | 1. 来自ACR的感知结果<br>2. 来自DMS的数据<br>3. 用户指令      | 1. 对HAL的控制指令<br>2. 对API的用户反馈                     | **Python**, PyTorch                        |
| **ACR (算法容器层)**                      | 提供一系列原子化的、可被独立调用的“算法能力”。               | 1. 视觉感知容器(检测/分割)<br>2. 语音处理容器(ASR/TTS)<br>3. SLAM/定位容器<br>4. 运动规划容器 | 1. 来自DMS的传感器数据流                                     | 1. 标准化的感知结果（如检测框、文本、位姿）                  | **Go (运行时)**, **Python (封装)**, Docker |
| **HAL (硬件抽象层)**                      | 屏蔽硬件差异，为所有物理设备提供标准化的gRPC接口。           | 1. 相机驱动容器<br>2. LiDAR驱动容器<br>3. IMU驱动容器<br>4. 电机/机械臂驱动容器 | 1. 来自DIL的控制指令<br>**2. <ins>来自遥操作的直接指令</ins>** | 1. 标准化的原始传感器数据<br>2. 硬件状态信息                 | **Rust**, **C++**                          |
| **RTS (实时调度层)**                      | 保证关键任务（如电机控制、安全回路）的确定性响应。           | 1. 实时任务调度器<br>2. 高优先级通信通道(DDS)<br>3. 时间同步 | 1. 标记为“实时”的任务请求<br>**2. <ins>来自遥操作的低延迟指令</ins>** | 1. 有时间保障的任务执行                                      | **C++**, PREEMPT_RT                        |
| **DMS (<ins>数据采集与管理层</ins>)**     | **<ins>作为边缘端的数据中枢，负责所有数据的采集、记录、</ins>** 标准化、路由、本地缓存和与云端的同步。 | **<ins>1. 数据采集与记录器 (Rosbag-like)</ins>**<br>2. 数据总线 (Redis/ZeroMQ)<br>3. 云同步代理 | 1. 来自HAL的原始数据<br>2. 来自ACR/DIL的处理结果             | 1. 流向各模块的数据流<br>2. 待上传到云端的数据包             | **Go**, **Python**                         |
| **Dev (开发者生态)**                      | 为生态系统中的开发者提供工具链和支持。                       | 1. **`arf-cli`**: 命令行工具<br>2. **Python SDK**: 软件开发包<br>3. **文档中心** | N/A                                                          | N/A                                                          | **Go (CLI)**, **Python (SDK)**             |

## 第三部分：标准作业流程 (SOP) 概览

| **SOP ID** | **面向角色**                    | **核心目标**                                                 | **主要活动 (细化流程)**                                      | **关键交付物**                                               |
| ---------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **SOP-01** | **科研人员**                    | 探索并验证新的具身智能算法。                                 | 1.  **【启动】** 使用`arf-cli dev setup`命令一键拉取预配置的开发容器。<br>2.  **【数据】** 通过SDK访问`数据中心`的脱敏数据集，进行分析和实验。<br>3.  **【研发】** 在JupyterLab环境中使用PyTorch/TensorFlow进行模型设计与训练。<br>4.  **【验证】** 将训练好的模型连接到本地`仿真模块`实例，进行初步的功能验证。<br>5.  **【提交】** 将最终的“算法包”提交到Git仓库，并通知核心开发者进行工程化。 | 1.  模型文件 (`.pth`, `.onnx`等)<br>2.  标准化的`infer.py`脚本<br>3.  `requirements.txt`依赖文件<br>4.  一份简要的算法说明和性能报告。 |
| **SOP-02** | **核心开发者**<br>(MLOps工程师) | 将科研算法工程化，并安全、可靠地集成到ARF生态中。            | 1.  **【对接】** 与科研人员开会，共同定义算法的`.proto`接口。<br>2.  **【封装】** 将“算法包”封装成标准的、可复现的ACR/HAL容器。<br>3.  **【评测】** 将容器提交到`评测模块`，执行标准化的回归测试和性能评估。<br>4.  **【发布】** 评测通过后，将ACR容器发布到`插件市场`，并编写清晰的插件文档。 | 1.  版本化的ACR/HAL容器镜像<br>2.  自动生成的详细评测报告<br>3.  面向其他开发者的插件使用文档。 |
| **SOP-03** | **产业用户**<br>(应用部署)      | 在生产环境中高效、稳定地部署和使用ARF解决方案。              | 1.  **【规划】** 与ARF解决方案团队沟通业务需求，进行现场勘查。<br>2.  **【选型】** 从`插件市场`选择适配的`应用套件`和硬件驱动。<br>3.  **【集成】** 部署团队协助客户完成现场硬件与ARF `HAL`的对接与标定。<br>4.  **【上线】** 使用`舰队管理`工具，将应用套件一键部署到现场的机器人集群。<br>5.  **【运维】** 通过统一的Web控制台监控机器人状态、收集数据，并接收云端更新。 | 1.  一套稳定运行的机器人生产系统<br>2.  可视化的业务数据报表<br>3.  完整的运维手册和培训。 |
| **SOP-04** | **二次开发者**<br>(系统集成商)  | 基于ARF平台，为最终客户高效地开发和交付定制化的机器人应用。  | 1.  **【学习】** 注册成为ARF开发者，学习SDK、API文档和最佳实践教程。<br>2.  **【构建】** 从`插件市场`调用官方或社区的算法与驱动，作为应用基础。<br>3.  **【开发】** 使用Python SDK编写自定义的`DIL`决策逻辑，或开发全新的`ACR`容器来满足特定业务需求。<br>4.  **【分发】** 将定制化的解决方案打包成一个新的`应用套件`，并通过`插件市场`分发给自己的客户（可选择公开发布或私有部署）。 | 1.  一个或多个定制化的应用套件<br>2.  面向最终客户的解决方案文档<br>3.  (可选)发布到`插件市场`并可能产生收益的新插件。 |
| **SOP-05** | **家庭用户**                    | 安全、便捷地使用家庭服务机器人，并通过日常交互为生态贡献有价值的数据。 | 1.  **【开箱】** 通过移动App扫描二维码，引导机器人完成联网与自检。<br>2.  **【探索】** 在移动App的“技能商店”中浏览并一键安装新功能（如“智能陪聊”、“健康提醒”、“宠物互动”）。<br>3.  **【交互】** 通过语音和App与机器人进行日常任务交互。<br>4.  **【共建】** (在用户完全知情并授权下)通过App对技能进行评分、提交反馈，并选择是否加入“机器人进化计划”，分享匿名的交互数据，帮助机器人变得更聪明。 | 1.  一个能不断学习和成长的个性化机器人助手<br>               |